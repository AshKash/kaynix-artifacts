/**
 * Base Site Adapter - Interface for site-specific copilot implementations
 * Each e-commerce site gets its own adapter to handle site-specific quirks
 */

export class BaseSiteAdapter {
  constructor(domain, config = {}) {
    this.domain = domain;
    this.config = config;
    this.debug = config.debug;
    console.log(`[BaseSiteAdapter] Initialized for domain: ${this.domain}, Debug: ${this.debug}`);
  }

  /**
   * Get the current domain this adapter handles
   */
  getDomain() {
    return this.domain;
  }

  /**
   * Search for products on the site
   * @param {string} query - Search term
   * @param {Object} options - Search options
   * @returns {Promise<Object>} Search result
   */
  async search(query, options = {}) {
    throw new Error('search() must be implemented by site adapter');
  }

  /**
   * Extract products from the current page
   * @param {Object} options - Extraction options
   * @returns {Promise<Object>} Products found on page
   */
  async extractProducts(options = {}) {
    throw new Error('extractProducts() must be implemented by site adapter');
  }

  /**
   * Apply filters to the current search/category page
   * @param {Object} filters - Filters to apply (price, brand, size, etc.)
   * @returns {Promise<Object>} Filter application result
   */
  async applyFilters(filters = {}) {
    throw new Error('applyFilters() must be implemented by site adapter');
  }

  /**
   * Add a product to cart
   * @param {string} productId - Product identifier
   * @param {Object} options - Product options (size, color, quantity)
   * @returns {Promise<Object>} Add to cart result
   */
  async addToCart(productId, options = {}) {
    throw new Error('addToCart() must be implemented by site adapter');
  }

  /**
   * Extract available filters from the current page
   * @returns {Promise<Object>} Available filters (brands, sizes, colors, etc.)
   */
  async extractAvailableFilters() {
    throw new Error('extractAvailableFilters() must be implemented by site adapter');
  }

  /**
   * Clear all applied filters
   * @returns {Promise<Object>} Clear result
   */
  async clearFilters() {
    throw new Error('clearFilters() must be implemented by site adapter');
  }

  /**
   * Get current filter state
   * @returns {Object} Current filter values
   */
  getFilterState() {
    throw new Error('getFilterState() must be implemented by site adapter');
  }

  /**
   * Sort products by given criteria
   * @param {string} sortOption - Sort option (price-low, price-high, rating, etc.)
   * @returns {Promise<Object>} Sort result
   */
  async sortBy(sortOption) {
    throw new Error('sortBy() must be implemented by site adapter');
  }

  /**
   * Wait for page content to load after interactions
   * @param {number} timeout - Timeout in milliseconds
   * @returns {Promise<boolean>} Whether page loaded successfully
   */
  async waitForPageLoad(timeout = 5000) {
    throw new Error('waitForPageLoad() must be implemented by site adapter');
  }

  /**
   * Detect the current page type
   * @returns {string} Page type (search, product, category, home, etc.)
   */
  detectPageType() {
    // Use global window if available (for tests), otherwise use window
    const win = (typeof global !== 'undefined' && global.window) || window;
    const path = win.location.pathname.toLowerCase();
    const search = win.location.search.toLowerCase();

    if (path.includes('/product') || path.includes('/p/')) return 'product';
    if (path.includes('/search') || search.includes('q=')) return 'search';
    if (path.includes('/category') || path.includes('/c/')) return 'category';
    if (path === '/' || path === '') return 'home';
    if (path.includes('/cart')) return 'cart';

    return 'other';
  }

  /**
   * Get current page context information
   * @returns {Object} Page context
   */
  getPageContext() {
    return {
      url: window.location.href,
      pathname: window.location.pathname,
      search: window.location.search,
      title: document.title,
      type: this.detectPageType(),
      domain: this.domain
    };
  }

  // Utility methods that adapters can use

  /**
   * Wait for a selector to appear with timeout
   */
  async waitForSelector(selector, timeout = 5000) {
    const startTime = Date.now();

    while (Date.now() - startTime < timeout) {
      const element = document.querySelector(selector);
      if (element && element.offsetParent !== null) { // Check if visible
        return element;
      }
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    throw new Error(`Timeout waiting for selector: ${selector}`);
  }

  /**
   * Wait for any of multiple selectors
   */
  async waitForAnySelector(selectors, timeout = 5000) {
    const selectorList = Array.isArray(selectors) ? selectors : [selectors];
    const startTime = Date.now();

    while (Date.now() - startTime < timeout) {
      for (const selector of selectorList) {
        const element = document.querySelector(selector);
        if (element && element.offsetParent !== null) {
          return { element, selector };
        }
      }
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    throw new Error(`Timeout waiting for any selector: ${selectorList.join(', ')}`);
  }

  /**
   * Alias for waitForSelector for compatibility
   */
  async waitForElement(selector, timeout = 5000) {
    return this.waitForSelector(selector, timeout);
  }

  /**
   * Safe click that scrolls element into view first
   */
  async safeClick(element, options = {}) {
    if (!element) {
      throw new Error('No element to click');
    }

    // Scroll into view
    element.scrollIntoView({
      behavior: 'smooth',
      block: 'center',
      inline: 'center'
    });

    // Wait for scroll animation
    await new Promise(resolve => setTimeout(resolve, options.scrollDelay || 300));

    // Ensure element is still visible and clickable
    if (element.offsetParent === null) {
      throw new Error('Element is not visible');
    }

    // Click the element
    element.click();

    // Optional: wait after click
    if (options.waitAfter) {
      await new Promise(resolve => setTimeout(resolve, options.waitAfter));
    }
  }

  /**
   * Type text with realistic timing
   */
  async typeText(element, text, options = {}) {
    if (!element) {
      throw new Error('No element to type into');
    }

    const {
      clearFirst = true,
      delay = 50,
      triggerEvents = true
    } = options;

    // Focus the element
    element.focus();

    // Clear existing text if requested
    if (clearFirst) {
      element.value = '';
      if (triggerEvents) {
        element.dispatchEvent(new Event('input', { bubbles: true }));
      }
    }

    // Type character by character
    for (const char of text) {
      element.value += char;
      if (triggerEvents) {
        element.dispatchEvent(new Event('input', { bubbles: true }));
      }
      if (delay > 0) {
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }

    // Final events
    if (triggerEvents) {
      element.dispatchEvent(new Event('change', { bubbles: true }));
      element.dispatchEvent(new KeyboardEvent('keydown', {
        key: 'Enter',
        code: 'Enter',
        bubbles: true
      }));
    }
  }

  /**
   * Extract text content safely
   */
  extractText(element) {
    if (!element) return '';
    return (element.textContent && element.textContent.trim()) || (element.innerText && element.innerText.trim()) || '';
  }

  /**
   * Extract price from text using common patterns
   */
  extractPrice(text) {
    if (!text) return null;

    // Remove currency symbols but keep numbers, dots, and commas
    const cleanedText = text.replace(/[^\d.,]/g, '');

    // Match price patterns: 1,299.99 or 1299.99 or 99
    const priceMatch = cleanedText.match(/(\d{1,3}(?:,\d{3})*(?:\.\d{2})?|\d+(?:\.\d{2})?)/);

    if (priceMatch) {
      // Remove commas before parsing
      return parseFloat(priceMatch[1].replace(/,/g, ''));
    }

    return null;
  }


  /**
   * Find checkbox by text content
   */
  async findCheckboxByText(text, retries = 3) {
    for (let i = 0; i < retries; i++) {
      // Try multiple strategies to find checkboxes
      const strategies = [
        // Strategy 1: Label contains text and has checkbox
        () => {
          const labels = Array.from(document.querySelectorAll('label'));
          for (const label of labels) {
            if (label.textContent.toLowerCase().includes(text.toLowerCase())) {
              const checkbox = label.querySelector('input[type="checkbox"]');
              if (checkbox) return checkbox;

              // Check if label has 'for' attribute
              const forId = label.getAttribute('for');
              if (forId) {
                const checkbox = document.getElementById(forId);
                if (checkbox && checkbox.type === 'checkbox') return checkbox;
              }
            }
          }
          return null;
        },

        // Strategy 2: Checkbox with value matching text
        () => {
          const checkboxes = document.querySelectorAll('input[type="checkbox"]');
          for (const checkbox of checkboxes) {
            if (checkbox.value && checkbox.value.toLowerCase() === text.toLowerCase()) {
              return checkbox;
            }
          }
          return null;
        },

        // Strategy 3: Checkbox with aria-label matching text
        () => {
          const checkboxes = document.querySelectorAll('input[type="checkbox"]');
          for (const checkbox of checkboxes) {
            const ariaLabel = checkbox.getAttribute('aria-label');
            if (ariaLabel && ariaLabel.toLowerCase().includes(text.toLowerCase())) {
              return checkbox;
            }
          }
          return null;
        },

        // Strategy 4: Checkbox near text
        () => {
          const checkboxes = document.querySelectorAll('input[type="checkbox"]');
          for (const checkbox of checkboxes) {
            const parent = checkbox.parentElement;
            if (parent && parent.textContent.toLowerCase().includes(text.toLowerCase())) {
              return checkbox;
            }
          }
          return null;
        }
      ];

      for (const strategy of strategies) {
        const checkbox = strategy();
        if (checkbox) return checkbox;
      }

      if (i < retries - 1) {
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }

    return null;
  }

  /**
   * Wait for products to update after filter/action
   */
  async waitForProductUpdate(timeout = 3000) {
    // Wait a bit for any animations/transitions
    await new Promise(resolve => setTimeout(resolve, 300));

    // Try to detect loading indicators
    const loadingSelectors = [
      '.loading', '.spinner', '.loader',
      '[data-loading]', '.is-loading',
      '.product-loading', '.updating'
    ];

    for (const selector of loadingSelectors) {
      const loader = document.querySelector(selector);
      if (loader && loader.offsetParent !== null) {
        // Wait for loader to disappear
        const startTime = Date.now();
        while (Date.now() - startTime < timeout) {
          if (!loader.offsetParent) break;
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
    }

    // Additional wait for DOM to stabilize
    await new Promise(resolve => setTimeout(resolve, 500));
  }

  /**
   * Find element by text with flexible matching options
   */
  async findElementByText(selector, text, options = {}) {
    const {
      exact = false,
      ignoreCase = true,
      stripCount = true,  // Remove (123) counts
      stripSymbols = true // Remove ✓, ×, etc.
    } = options;

    const elements = document.querySelectorAll(selector);
    for (const element of elements) {
      let elementText = this.extractText(element);

      // Apply text transformations based on options
      if (stripCount) {
        elementText = elementText.replace(/\s*\(\d+\)\s*$/, '');
      }
      if (stripSymbols) {
        elementText = elementText.replace(/[✓×✗✔➜→]/g, '').trim();
      }

      const compareText = ignoreCase ? elementText.toLowerCase() : elementText;
      const searchText = ignoreCase ? text.toLowerCase() : text;

      if (exact ? compareText === searchText : compareText.includes(searchText)) {
        return element;
      }
    }
    return null;
  }

  /**
   * Find radio button by text
   */
  async findRadioByText(text, retries = 3) {
    for (let i = 0; i < retries; i++) {
      // Try multiple strategies to find radio buttons
      const strategies = [
        // Strategy 1: Label contains text and has radio
        () => {
          const labels = Array.from(document.querySelectorAll('label'));
          for (const label of labels) {
            if (label.textContent.toLowerCase().includes(text.toLowerCase())) {
              const radio = label.querySelector('input[type="radio"]');
              if (radio) return radio;

              // Check if label has 'for' attribute
              const forId = label.getAttribute('for');
              if (forId) {
                const radio = document.getElementById(forId);
                if (radio && radio.type === 'radio') return radio;
              }
            }
          }
          return null;
        },

        // Strategy 2: Radio with value matching text
        () => {
          const radios = document.querySelectorAll('input[type="radio"]');
          for (const radio of radios) {
            if (radio.value && radio.value.toLowerCase() === text.toLowerCase()) {
              return radio;
            }
          }
          return null;
        },

        // Strategy 3: Radio with aria-label matching text
        () => {
          const radios = document.querySelectorAll('input[type="radio"]');
          for (const radio of radios) {
            const ariaLabel = radio.getAttribute('aria-label');
            if (ariaLabel && ariaLabel.toLowerCase().includes(text.toLowerCase())) {
              return radio;
            }
          }
          return null;
        }
      ];

      for (const strategy of strategies) {
        const radio = strategy();
        if (radio) return radio;
      }

      if (i < retries - 1) {
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }

    return null;
  }

  /**
   * Select option from dropdown
   */
  async selectDropdownOption(selectElement, optionText) {
    if (!selectElement) return false;

    const options = selectElement.querySelectorAll('option');
    for (const option of options) {
      if (option.textContent.toLowerCase().includes(optionText.toLowerCase())) {
        selectElement.value = option.value;
        selectElement.dispatchEvent(new Event('change', { bubbles: true }));
        return true;
      }
    }
    return false;
  }

  /**
   * Set price range (for slider inputs)
   */
  async setPriceRange(minPrice, maxPrice) {
    // Find price range inputs
    const minInput = document.querySelector('input[name*="min"][name*="price"], input[placeholder*="min"], input[aria-label*="minimum price"]');
    const maxInput = document.querySelector('input[name*="max"][name*="price"], input[placeholder*="max"], input[aria-label*="maximum price"]');

    if (minInput && minPrice !== null) {
      await this.typeText(minInput, minPrice.toString(), { clearFirst: true });
    }

    if (maxInput && maxPrice !== null) {
      await this.typeText(maxInput, maxPrice.toString(), { clearFirst: true });
    }

    // Look for apply button
    const applyButton = document.querySelector('button[class*="price"][class*="apply"], button[aria-label*="apply price"]');
    if (applyButton) {
      await this.safeClick(applyButton);
    }

    return !!(minInput || maxInput);
  }

  /**
   * Check if element indicates out of stock
   */
  isOutOfStock(element) {
    const indicators = [
      'out of stock', 'sold out', 'unavailable',
      'coming soon', 'notify me', 'out-of-stock',
      'nicht verfügbar', 'agotado', 'épuisé' // International
    ];
    const text = this.extractText(element).toLowerCase();
    return indicators.some(indicator => text.includes(indicator));
  }

  /**
   * Extract rating from element
   */
  extractRating(element) {
    if (!element) return null;

    // Look for star ratings
    const ratingElement = element.querySelector('[class*="rating"], [class*="star"], [aria-label*="rating"]');
    if (!ratingElement) return null;

    // Try aria-label first
    const ariaLabel = ratingElement.getAttribute('aria-label');
    if (ariaLabel) {
      const match = ariaLabel.match(/(\d+\.?\d*)\s*(out of|\/|stars?)/i);
      if (match) return parseFloat(match[1]);
    }

    // Try text content
    const text = this.extractText(ratingElement);
    const textMatch = text.match(/(\d+\.?\d*)\s*(\/\s*5|stars?|★)/i);
    if (textMatch) return parseFloat(textMatch[1]);

    // Count filled stars
    const filledStars = ratingElement.querySelectorAll('[class*="filled"], [class*="full"], .star.active');
    if (filledStars.length > 0) return filledStars.length;

    return null;
  }

  /**
   * Extract review count from element
   */
  extractReviewCount(element) {
    if (!element) return null;

    const reviewElement = element.querySelector('[class*="review"], [class*="rating"]');
    if (!reviewElement) return null;

    const text = this.extractText(reviewElement);
    const match = text.match(/\((\d+)\)|\b(\d+)\s*reviews?/i);

    if (match) {
      return parseInt(match[1] || match[2]);
    }

    return null;
  }

  /**
   * Logging utilities
   */
  log(...args) {
    if (this.debug) {
      console.log(`[${this.domain} Adapter]`, ...args);
    }
  }

  error(...args) {
    console.error(`[${this.domain} Adapter]`, ...args);
  }

  warn(...args) {
    console.warn(`[${this.domain} Adapter]`, ...args);
  }

  /**
   * MCP SERVER INTERFACE
   * Default implementation that subclasses can override
   */

  /**
   * Get MCP server capabilities
   * Subclasses should override to provide actual capabilities
   */
  getMCPCapabilities() {
    return {
      tools: []
    };
  }

  /**
   * Call an MCP tool
   * Subclasses should override to handle actual tool calls
   */
  async callMCPTool(toolName, parameters) {
    throw new Error(`MCP tool "${toolName}" not implemented by ${this.domain} adapter`);
  }
}

// Standard MCP tools that all adapters should implement
export const STANDARD_MCP_TOOLS = [
  {
    name: "search_products",
    description: "Search for products on the e-commerce site",
    inputSchema: {
      type: "object",
      properties: {
        query: { type: "string", description: "Search query" },
        filters: { type: "object", description: "Optional filters" }
      },
      required: ["query"]
    }
  },
  {
    name: "apply_filters",
    description: "Apply filters to product listing",
    inputSchema: {
      type: "object",
      properties: {
        filters: { type: "object", description: "Filters to apply" }
      },
      required: ["filters"]
    }
  },
  {
    name: "get_page_products",
    description: "Extract products from current page",
    inputSchema: {
      type: "object",
      properties: {}
    }
  },
  {
    name: "add_to_cart",
    description: "Add product to shopping cart",
    inputSchema: {
      type: "object",
      properties: {
        productId: { type: "string", description: "Product identifier" },
        size: { type: "string", description: "Product size" },
        quantity: { type: "number", description: "Quantity to add" }
      },
      required: ["productId"]
    }
  }
];

// Type definitions for MCP responses
export class MCPResponse {
  constructor(success, message, data = null, debug = null) {
    this.success = success;
    this.message = message;
    this.data = data;
    this.debug = debug;
  }
}

// JSON-LD Product Schema
export class ProductJsonLD {
  constructor(product) {
    this["@context"] = "https://schema.org/";
    this["@type"] = "Product";
    this.name = product.title;
    this.url = product.url;
    this.image = product.image;
    this.description = product.description;
    this.brand = product.brand ? { "@type": "Brand", "name": product.brand } : undefined;
    this.offers = {
      "@type": "Offer",
      price: product.price,
      priceCurrency: product.currency || "USD",
      availability: product.inStock ? "https://schema.org/InStock" : "https://schema.org/OutOfStock"
    };
    this.aggregateRating = product.rating ? {
      "@type": "AggregateRating",
      ratingValue: product.rating,
      reviewCount: product.reviewCount
    } : undefined;
  }
}

export default BaseSiteAdapter;
