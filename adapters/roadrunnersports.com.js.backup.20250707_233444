// Kaynix adapter for roadrunnersports.com
import BaseSiteAdapter from './base-adapter.js';

export default class RoadrunnersportscomAdapter extends BaseSiteAdapter {
  constructor() {
    super('roadrunnersports.com', {
      searchUrl: 'https://roadrunnersports.com/search?q={query}',
      categoryUrls: [
        "https://roadrunnersports.com/category/womens/apparel/outerwear",
        "https://roadrunnersports.com/category/womens/apparel/shorts",
        "https://roadrunnersports.com/category/womens/apparel/tightsandpants",
        "https://roadrunnersports.com/category/womens/shoes/new",
        "https://roadrunnersports.com/category/womens/shoes/outlet",
        "https://roadrunnersports.com/category/womens/apparel/outlet",
        "https://roadrunnersports.com/category/womens/accessories/outlet",
        "https://roadrunnersports.com/category/womens/shoes",
        "https://roadrunnersports.com/category/womens/shoes/running",
        "https://roadrunnersports.com/category/womens/shoes/trail-running",
        "https://roadrunnersports.com/category/womens/shoes/cross-training",
        "https://roadrunnersports.com/category/womens/shoes/racing",
        "https://roadrunnersports.com/category/womens/shoes/sandals",
        "https://roadrunnersports.com/category/womens/shoes/walking",
        "https://roadrunnersports.com/category/womens/shoes/casual",
        "https://roadrunnersports.com/category/womens/shoes/hiking",
        "https://roadrunnersports.com/category/womens/shoes/cross-country",
        "https://roadrunnersports.com/category/womens/shoes/court",
        "https://roadrunnersports.com/category/womens/shoes/pickleball",
        "https://roadrunnersports.com/category/womens/shoes/work-safety"
],
      productItemSelector: '.product-card, .product-item, article[data-product], [data-testid*="product"], .search-result-item, .product-tile, .plp-product-card',
      searchInputSelector: 'input[type="search"], input[name="q"], input[name="search"], input[placeholder*="search" i]',
      searchButtonSelector: 'button[type="submit"], button[class*="search"]'
    });
  }

  async search(query, options = {}) {
    try {
      const searchUrl = this.config.searchUrl.replace('{query}', encodeURIComponent(query));
      await this.navigateTo(searchUrl, options);

      await this.waitForSelector(this.config.productItemSelector, {
        timeout: options.timeout || 10000
      });

      const extractResult = await this.extractProducts(options);

      return {
        success: true,
        query: query,
        products: extractResult.products || [],
        count: extractResult.products?.length || 0
      };
    } catch (error) {
      console.error('[roadrunnersports.com] Search error:', error);
      return {
        success: false,
        query: query,
        error: error.message,
        products: []
      };
    }
  }

  async extractProducts(options = {}) {
    try {
      const products = [];
      console.log(`[roadrunnersports.com] Using selector: ${this.config.productItemSelector}`);

      // Wait for dynamic content to load (prices are likely loaded via JS)
      console.log(`[roadrunnersports.com] Waiting 2 seconds for dynamic content...`);
      await new Promise(resolve => setTimeout(resolve, 2000));

      // First try the configured selector
      let productElements = document.querySelectorAll(this.config.productItemSelector);
      console.log(`[roadrunnersports.com] Found ${productElements.length} product elements with primary selector`);

      // If no products found, try alternative selectors
      if (productElements.length === 0) {
        const alternativeSelectors = [
          'a[href*="/product/"]',  // Direct product links
          'a[href*="/product/"] > div',  // Product divs inside links
          'div[class*="product-card"]',  // Any div with product-card in class
          'div[class*="product-list"] > div > a',
          'div[class*="search-results"] article',
          'div[class*="ProductCard"]',
          'div[data-qa*="product"]'
        ];

        for (const selector of alternativeSelectors) {
          productElements = document.querySelectorAll(selector);
          if (productElements.length > 0) {
            console.log(`[roadrunnersports.com] Found ${productElements.length} products with fallback selector: ${selector}`);
            break;
          }
        }
      }

      for (let i = 0; i < productElements.length; i++) {
        const element = productElements[i];
        const productContainer = element;

        const product = {
          position: i + 1
        };

        // Extract title - look for actual product name elements
        const titleElement = productContainer.querySelector('h2, h3, h4, [class*="product-name"], [class*="product-title"], [data-qa="product-name"]');
        if (titleElement) {
          product.title = this.extractText(titleElement);
          if (i < 3) {
            console.log(`[roadrunnersports.com] Product ${i + 1} title element:`, titleElement);
            console.log(`[roadrunnersports.com] Product ${i + 1} extracted title:`, product.title);
          }
        }

        // Extract URL
        const linkElement = element.closest('a') || productContainer.querySelector('a[href*="/product"]');
        if (linkElement) {
          const href = linkElement.getAttribute('href');
          product.url = href.startsWith('http') ? href : `https://roadrunnersports.com${href}`;
        }

        // Extract price - try multiple strategies
        let priceElement = productContainer.querySelector('.price, [class*="price"], .cost, [data-price]');
        if (!priceElement) {
          // Try looking for dollar signs or price-like patterns
          priceElement = productContainer.querySelector('[class*="dollar"], [class*="amount"], [class*="currency"]');
        }
        if (!priceElement) {
          // Look for any element containing $ followed by numbers
          const allElements = productContainer.querySelectorAll('*');
          for (const el of allElements) {
            const text = this.extractText(el);
            if (text && /\$\d/.test(text)) {
              priceElement = el;
              break;
            }
          }
        }

        if (priceElement) {
          const priceText = this.extractText(priceElement);
          product.priceText = priceText;
          product.price = this.extractPrice(priceText);
        } else {
          // Debug: log the product container structure for first few products
          if (i < 3) {
            console.log(`[roadrunnersports.com] No price found for product ${i + 1}:`, productContainer.innerHTML.substring(0, 200));
          }
        }

        // Extract image
        const imageElement = productContainer.querySelector('img');
        if (imageElement) {
          product.image = imageElement.src || imageElement.getAttribute('data-src');
        }

        // Extract brand from title
        if (product.title) {
          product.brand = this.extractBrandFromName(product.title);
        }

        // Only add if we have at least title and URL
        if (product.title && product.url) {
          products.push(product);
        }
      }

      return {
        success: true,
        products: products
      };
    } catch (error) {
      console.error('[roadrunnersports.com] Error extracting products:', error);
      return {
        success: false,
        error: error.message,
        products: []
      };
    }
  }

  async applyFilters(filters) {
    try {
      let filtersApplied = 0;
      const notFound = [];

      // Handle brand filters
      if (filters.brands && filters.brands.length > 0) {
        for (const brand of filters.brands) {
          // Use improved findElementByText for better matching
          const checkbox = await this.findElementByText('input[type="checkbox"]', brand, {
            exact: false,
            stripCount: true,
            stripSymbols: true
          });

          if (checkbox && !checkbox.checked) {
            await this.safeClick(checkbox);
            await this.waitForProductUpdate();
            filtersApplied++;
          } else if (!checkbox) {
            notFound.push(`Brand: ${brand}`);
            console.warn(`[roadrunnersports.com] Could not find checkbox for brand: ${brand}`);
          }
        }
      }

      // Handle size filters with special logic for numeric sizes
      if (filters.sizes && filters.sizes.length > 0) {
        for (const size of filters.sizes) {
          // For numeric sizes, try exact match first
          let checkbox = null;

          if (/^\d+(\.\d+)?$/.test(size)) {
            // It's a numeric size, try exact match
            checkbox = await this.findElementByText('input[type="checkbox"]', size, {
              exact: true,
              stripCount: true
            });
          }

          // If not found or not numeric, try normal search
          if (!checkbox) {
            checkbox = await this.findElementByText('input[type="checkbox"]', size, {
              exact: false,
              stripCount: true
            });
          }

          if (checkbox && !checkbox.checked) {
            await this.safeClick(checkbox);
            await this.waitForProductUpdate();
            filtersApplied++;
          } else if (!checkbox) {
            notFound.push(`Size: ${size}`);
            console.warn(`[roadrunnersports.com] Could not find checkbox for size: ${size}`);
          }
        }
      }

      // Handle color filters
      if (filters.colors && filters.colors.length > 0) {
        for (const color of filters.colors) {
          const checkbox = await this.findElementByText('input[type="checkbox"]', color, {
            exact: false,
            stripCount: true
          });

          if (checkbox && !checkbox.checked) {
            await this.safeClick(checkbox);
            await this.waitForProductUpdate();
            filtersApplied++;
          } else if (!checkbox) {
            notFound.push(`Color: ${color}`);
            console.warn(`[roadrunnersports.com] Could not find checkbox for color: ${color}`);
          }
        }
      }

      // Handle width filters (e.g., "wide", "extra wide")
      if (filters.width) {
        const widthMapping = {
          'wide': "Men's Wide",
          'extra wide': "Men's Extra Wide",
          'narrow': "Men's Narrow"
        };

        const widthLabel = widthMapping[filters.width.toLowerCase()] || filters.width;
        const checkbox = await this.findElementByText('input[type="checkbox"]', widthLabel, {
          exact: false,
          stripCount: true
        });

        if (checkbox && !checkbox.checked) {
          await this.safeClick(checkbox);
          await this.waitForProductUpdate();
          filtersApplied++;
        } else if (!checkbox) {
          notFound.push(`Width: ${filters.width}`);
        }
      }

      // Handle price range
      if (filters.priceMax || filters.priceMin) {
        const applied = await this.setPriceRange(filters.priceMin, filters.priceMax);
        if (applied) {
          await this.waitForProductUpdate();
          filtersApplied++;
        }
      }

      // After applying filters, extract the updated products
      const productsResult = await this.extractProducts();

      let message = `Applied ${filtersApplied} filters`;
      if (notFound.length > 0) {
        message += `. Could not find: ${notFound.join(', ')}`;
      }

      return {
        success: true,
        filtersApplied: filtersApplied,
        filtersNotFound: notFound,
        message: message,
        products: productsResult.products || []
      };
    } catch (error) {
      console.error('[roadrunnersports.com] Error applying filters:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  async extractAvailableFilters() {
    console.log('[roadrunnersports.com] extractAvailableFilters called');
    try {
      const filters = {
        brands: [],
        colors: [],
        sizes: [],
        priceRanges: [],
        categories: [],
        sortOptions: []
      };

      // Find filter containers - RoadRunner Sports specific
      // Try multiple strategies to find filters
      let filterContainers = document.querySelectorAll(
        '.filters, .sidebar, .filter-sidebar, [data-filters], .facets, .refinements, .product-filters, .plp-filters'
      );

      // If no containers found, try to find the left sidebar or filter area
      if (filterContainers.length === 0) {
        console.log('[roadrunnersports.com] No filter containers found with primary selectors, trying alternatives');
        filterContainers = document.querySelectorAll(
          'aside, [role="complementary"], .left-sidebar, .filter-panel, div[class*="filter"]'
        );
      }

      console.log(`[roadrunnersports.com] Found ${filterContainers.length} potential filter containers`);

      // If still no containers, try to extract filters from the entire page
      if (filterContainers.length === 0) {
        console.log('[roadrunnersports.com] No containers found, searching entire page for filters');
        filterContainers = [document.body];
      }

      for (const container of filterContainers) {
        // Extract brand filters - look for checkboxes with brand names
        const brandCheckboxes = container.querySelectorAll(
          'input[type="checkbox"][name*="brand"], ' +
          'input[type="checkbox"][value*="Nike"], ' +
          'input[type="checkbox"][value*="Adidas"], ' +
          'input[type="checkbox"][value*="Brooks"], ' +
          'label:has(input[type="checkbox"]) + span'
        );

        if (brandCheckboxes.length > 0) {
          console.log(`[roadrunnersports.com] Found ${brandCheckboxes.length} potential brand filters`);
        }

        brandCheckboxes.forEach(checkbox => {
          const label = this.extractText(checkbox.parentElement || checkbox.nextElementSibling);
          if (label) {
            filters.brands.push({
              label: label,
              value: checkbox.value || label.toLowerCase().replace(/\s+/g, '-'),
              isChecked: checkbox.checked || false,
              count: this.extractCountFromLabel(label)
            });
          }
        });

        // Extract size filters
        const sizeSection = container.querySelector('[data-filter="size"], .size-filter, .sizes');
        if (sizeSection) {
          const sizeOptions = sizeSection.querySelectorAll('input[type="checkbox"], .filter-option, .size-option');
          sizeOptions.forEach(option => {
            const label = this.extractText(option.parentElement || option.nextElementSibling);
            if (label) {
              filters.sizes.push({
                label: label,
                value: option.value || label.toLowerCase(),
                isChecked: option.checked || false,
                count: this.extractCountFromLabel(label)
              });
            }
          });
        }

        // Extract color filters
        const colorSection = container.querySelector('[data-filter="color"], .color-filter, .colors');
        if (colorSection) {
          const colorOptions = colorSection.querySelectorAll('input[type="checkbox"], .filter-option, .color-option');
          colorOptions.forEach(option => {
            const label = this.extractText(option.parentElement || option.nextElementSibling);
            if (label) {
              filters.colors.push({
                label: label,
                value: option.value || label.toLowerCase(),
                isChecked: option.checked || false,
                count: this.extractCountFromLabel(label)
              });
            }
          });
        }
      }

      // If no filters found, try to detect from any checkboxes on the page
      if (filters.brands.length === 0 && filters.sizes.length === 0 && filters.colors.length === 0) {
        console.log('[roadrunnersports.com] No filters found via containers, trying direct checkbox detection');

        const allCheckboxes = document.querySelectorAll('input[type="checkbox"]');
        console.log(`[roadrunnersports.com] Found ${allCheckboxes.length} total checkboxes on page`);

        allCheckboxes.forEach(checkbox => {
          const label = this.extractText(checkbox.parentElement) ||
                       this.extractText(checkbox.nextElementSibling) ||
                       checkbox.getAttribute('aria-label') ||
                       checkbox.value;

          if (label && label.length > 0 && label.length < 50) {
            // Try to categorize based on content
            const lowerLabel = label.toLowerCase();

            // Size patterns
            if (lowerLabel.match(/^(xs|s|m|l|xl|xxl|\d+(\.\d+)?|small|medium|large)$/i)) {
              filters.sizes.push({
                label: label,
                value: checkbox.value || label,
                isChecked: checkbox.checked,
                count: this.extractCountFromLabel(label)
              });
            }
            // Color patterns
            else if (lowerLabel.match(/(black|white|red|blue|green|yellow|orange|purple|pink|gray|grey|brown)/i)) {
              filters.colors.push({
                label: label,
                value: checkbox.value || label,
                isChecked: checkbox.checked,
                count: this.extractCountFromLabel(label)
              });
            }
            // Known brands
            else if (lowerLabel.match(/(nike|adidas|brooks|asics|saucony|new balance|hoka|under armour)/i)) {
              filters.brands.push({
                label: label,
                value: checkbox.value || label,
                isChecked: checkbox.checked,
                count: this.extractCountFromLabel(label)
              });
            }
          }
        });
      }

      // Extract sort options
      const sortSelect = document.querySelector('select[name*="sort"], .sort-select, #sort-options');
      if (sortSelect) {
        const options = sortSelect.querySelectorAll('option');
        options.forEach(option => {
          if (option.value && option.textContent.trim()) {
            filters.sortOptions.push({
              label: option.textContent.trim(),
              value: option.value
            });
          }
        });
      }

      return filters;
    } catch (error) {
      console.error('[roadrunnersports.com] Error extracting filters:', error);
      return {
        brands: [],
        colors: [],
        sizes: [],
        priceRanges: [],
        categories: [],
        sortOptions: []
      };
    }
  }

  // Helper method to extract count from filter labels like "Nike (12)"
  extractCountFromLabel(label) {
    const match = label.match(/\((\d+)\)/);
    return match ? parseInt(match[1]) : null;
  }

  // Helper to extract brand from product name
  extractBrandFromName(name) {
    const knownBrands = ['Nike', 'Adidas', 'Brooks', 'ASICS', 'Saucony', 'New Balance', 'HOKA', 'Under Armour'];
    for (const brand of knownBrands) {
      if (name.toLowerCase().includes(brand.toLowerCase())) {
        return brand;
      }
    }
    return '';
  }

  // Clear all applied filters
  async clearFilters() {
    try {
      // Look for clear all button
      const clearButtons = document.querySelectorAll(
        'button[class*="clear-all"], button[class*="reset"], a[class*="clear-all"], button:contains("Clear")'
      );

      for (const button of clearButtons) {
        if (this.extractText(button).toLowerCase().includes('clear')) {
          await this.safeClick(button);
          await this.waitForProductUpdate();
          return { success: true, message: 'Filters cleared' };
        }
      }

      // If no clear all button, uncheck all checked filters
      const checkedFilters = document.querySelectorAll('input[type="checkbox"]:checked, input[type="radio"]:checked');
      let cleared = 0;

      for (const filter of checkedFilters) {
        await this.safeClick(filter);
        cleared++;
        if (cleared % 5 === 0) { // Wait every 5 filters to avoid overwhelming the page
          await this.waitForProductUpdate();
        }
      }

      if (cleared > 0) {
        await this.waitForProductUpdate();
      }

      return {
        success: true,
        message: `Cleared ${cleared} filters`,
        filtersCleared: cleared
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  // Get current state of all filters
  getFilterState() {
    const state = {
      brands: [],
      sizes: [],
      colors: [],
      widths: [],
      priceRange: null,
      sortBy: null
    };

    // Get all checked checkboxes
    const checkedBoxes = document.querySelectorAll('input[type="checkbox"]:checked');

    checkedBoxes.forEach(checkbox => {
      const label = this.extractText(checkbox.parentElement) ||
                   this.extractText(checkbox.nextElementSibling) ||
                   checkbox.value;

      // Categorize based on parent container or label content
      const container = checkbox.closest('[data-filter-type], [class*="filter"]');
      const containerText = container ? this.extractText(container).toLowerCase() : '';

      if (containerText.includes('brand') || label.match(/nike|adidas|brooks|asics/i)) {
        state.brands.push(label);
      } else if (containerText.includes('size') || label.match(/^\d+(\.\d+)?$/)) {
        state.sizes.push(label);
      } else if (containerText.includes('color') || label.match(/black|white|red|blue/i)) {
        state.colors.push(label);
      } else if (containerText.includes('width') || label.includes('Wide')) {
        state.widths.push(label);
      }
    });

    // Get sort state
    const sortSelect = document.querySelector('select[name*="sort"], .sort-select');
    if (sortSelect) {
      state.sortBy = sortSelect.value;
    }

    return state;
  }

  // Sort products
  async sortBy(sortOption) {
    try {
      const sortSelect = document.querySelector('select[name*="sort"], .sort-select, #sort-options');

      if (!sortSelect) {
        return { success: false, error: 'Sort dropdown not found' };
      }

      // Map common sort options to site-specific values
      const sortMapping = {
        'price-low': 'price-asc',
        'price-high': 'price-desc',
        'rating': 'rating-desc',
        'newest': 'newest',
        'bestselling': 'best-sellers'
      };

      const mappedOption = sortMapping[sortOption] || sortOption;

      // Try to select the option
      const selected = await this.selectDropdownOption(sortSelect, mappedOption);

      if (selected) {
        await this.waitForProductUpdate();
        return { success: true, message: `Sorted by ${sortOption}` };
      }

      return { success: false, error: `Sort option '${sortOption}' not found` };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  // MCP capabilities - define what tools this adapter supports
  getMCPCapabilities() {
    return {
      tools: [
        {
          name: "search_products",
          description: "Search for products on Road Runner Sports",
          inputSchema: {
            type: "object",
            properties: {
              query: { type: "string", description: "Search query for products" }
            },
            required: ["query"]
          }
        },
        {
          name: "apply_filters",
          description: "Apply filters like brand, size, color to refine products",
          inputSchema: {
            type: "object",
            properties: {
              filters: {
                type: "object",
                properties: {
                  brands: { type: "array", items: { type: "string" } },
                  sizes: { type: "array", items: { type: "string" } },
                  colors: { type: "array", items: { type: "string" } }
                }
              }
            },
            required: ["filters"]
          }
        }
      ]
    };
  }

  // Handle MCP tool calls
  async callMCPTool(toolName, parameters) {
    switch (toolName) {
      case 'search_products':
        return await this.search(parameters.query);

      case 'apply_filters':
        return await this.applyFilters(parameters.filters);

      default:
        throw new Error(`Unknown MCP tool: ${toolName}`);
    }
  }

  // Version information for debugging
  getVersion() {
    const now = new Date();
    const timeStr = now.toLocaleString("en-US", {
      timeZone: "America/Los_Angeles",
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false
    }).replace(/(\d+)\/(\d+)\/(\d+),\s(.+)/, '$3-$1-$2 $4');

    // Hash the entire class implementation
    const classCode = this.constructor.toString();
    const hash = classCode.split('').reduce((a,b) => {
      a = ((a << 5) - a) + b.charCodeAt(0);
      return a & a;
    }, 0);

    return `roadrunner-v2.4-${timeStr} PST [hash:${Math.abs(hash)}]`;
  }
}
